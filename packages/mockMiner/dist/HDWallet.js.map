{"version":3,"sources":["../src/HDWallet.js"],"names":["bip39","require","ethJSWallet","hdkey","Transaction","ethUtils","starting_wallet_hdpath","normalizePrivateKeys","Array","isArray","mnemonic","includes","checkBIP39Mnemonic","address_index","num_addresses","seed","mnemonicToSeedSync","hdwallet","fromMasterSeed","addresses","wallets","i","wallet","derivePath","getWallet","addr","getAddress","toString","push","ethUtilValidation","privateKey","Buffer","from","privateKeys","replace","isValidPrivate","fromPrivateKey","address","getAddressString","HDWallet","shareNonce","numberAddresses","addressIndex","forEach","fn","bind","tmp_accounts","tmp_wallets","getPrivateKey","cb","console","group","log","groupEnd","a","e","k","signTransaction","txParams","pkey","toLowerCase","tx","sign","rawTx","serialize","signMessage","data","dataIfExists","dataBuff","ethUtil","toBuffer","msgHashBuff","hashPersonalMessage","sig","ecsign","rpcSig","toRpcSig","v","r","s","signPersonalMessage"],"mappings":"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","file":"HDWallet.js","sourcesContent":["\n//Largely borrowed from Truffle's HD wallet impl\n\nconst bip39 = require(\"bip39\");\nconst ethJSWallet = require(\"ethereumjs-wallet\");\nconst hdkey = require(\"ethereumjs-wallet/hdkey\");\nconst Transaction = require(\"ethereumjs-tx\");\nconst ethUtils = require('ethereumjs-util');\nconst starting_wallet_hdpath = \"m/44'/60'/0'/0/\";\n\n\n// private helper to normalize given mnemonic\nconst normalizePrivateKeys = mnemonic => {\n  if (Array.isArray(mnemonic)) return mnemonic;\n  else if (mnemonic && !mnemonic.includes(\" \")) return [mnemonic];\n  // if truthy, but no spaces in mnemonic\n  else return false; // neither an array nor valid value passed;\n};\n\n// private helper to check if given mnemonic uses BIP39 passphrase protection\nconst checkBIP39Mnemonic = (mnemonic, address_index, num_addresses) => {\n  let seed = bip39.mnemonicToSeedSync(mnemonic);\n  let hdwallet = hdkey.fromMasterSeed(seed);\n  /*if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error(\"Mnemonic invalid or undefined\");\n  }*/\n\n  let addresses = [];\n  let wallets = [];\n  // crank the addresses out\n  for (let i = address_index; i < address_index + num_addresses; i++) {\n    const wallet = hdwallet\n      .derivePath(starting_wallet_hdpath + i)\n      .getWallet();\n    const addr = `0x${wallet.getAddress().toString(\"hex\")}`;\n    addresses.push(addr);\n    wallets[addr] = wallet;\n  }\n\n  return {\n    addresses,\n    wallets,\n    hdwallet\n  }\n};\n\n// private helper leveraging ethUtils to populate wallets/addresses\nconst ethUtilValidation = privateKeys => {\n  // crank the addresses out\n  let addresses = [];\n  let wallets = [];\n  for (let i = address_index; i < address_index + num_addresses; i++) {\n    const privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n    if (ethUtils.isValidPrivate(privateKey)) {\n      const wallet = ethJSWallet.fromPrivateKey(privateKey);\n      const address = wallet.getAddressString();\n      addresses.push(address);\n      wallets[address] = wallet;\n    }\n  }\n  return {\n    addresses,\n    wallets\n  }\n};\n\n\nexport default class HDWallet {\n  constructor({\n    mnemonic,\n    num_addresses,\n    address_index,\n    shareNonce\n  }) {\n\n    if(!num_addresses) {\n      num_addresses = 10;\n    }\n    if(!address_index) {\n      address_index = 0;\n    }\n    if(typeof shareNonce === 'undefined') {\n      shareNonce = true;\n    }\n\n    this.numberAddresses = num_addresses;\n    this.addressIndex = address_index;\n    this.shareNonce = shareNonce;\n    this.mnemonic = mnemonic;\n\n    [\n      'init'\n    ].forEach(fn=>this[fn]=this[fn].bind(this));\n  }\n\n  async init() {\n    const privateKeys = normalizePrivateKeys(this.mnemonic);\n\n    if (!privateKeys) {\n      let {addresses,wallets, hdwallet} = await checkBIP39Mnemonic(this.mnemonic, this.addressIndex, this.numberAddresses);\n      this.addresses = addresses;\n      this.wallets = wallets;\n      this.hdwallet = hdwallet;\n    } else {\n      let {addresses, wallets} = ethUtilValidation(privateKeys);\n      this.addresses = addresses;\n      this.wallets = wallets;\n    }\n\n    const tmp_accounts = this.addresses;\n    const tmp_wallets = this.wallets;\n\n    this.getPrivateKey = (address, cb) => {\n      if (!tmp_wallets[address]) {\n        return cb(\"Account not found\");\n      } else {\n        cb(null, tmp_wallets[address].getPrivateKey().toString(\"hex\"));\n      }\n    };\n\n    console.group(\"Addresses\");\n    console.log(this.addresses);\n    console.groupEnd();\n    console.group(\"Private Keys\");\n    console.log(\"[\");\n    this.addresses.forEach(a=>this.getPrivateKey(a, (e,k)=>console.log(k)));\n    console.log(\"]\");\n    console.groupEnd();\n\n    this.signTransaction = (txParams, cb) => {\n      let pkey;\n      const from = txParams.from.toLowerCase();\n      if (tmp_wallets[from]) {\n        pkey = tmp_wallets[from].getPrivateKey();\n      } else {\n        cb(\"Account not found\");\n      }\n      const tx = new Transaction(txParams);\n      tx.sign(pkey);\n      const rawTx = `0x${tx.serialize().toString(\"hex\")}`;\n      cb(null, rawTx);\n    };\n\n    this.signMessage = ({ data, from }, cb) => {\n      const dataIfExists = data;\n      if (!dataIfExists) {\n        cb(\"No data to sign\");\n      }\n      if (!tmp_wallets[from]) {\n        cb(\"Account not found\");\n      }\n      let pkey = tmp_wallets[from].getPrivateKey();\n      const dataBuff = ethUtil.toBuffer(dataIfExists);\n      const msgHashBuff = ethUtil.hashPersonalMessage(dataBuff);\n      const sig = ethUtil.ecsign(msgHashBuff, pkey);\n      const rpcSig = ethUtil.toRpcSig(sig.v, sig.r, sig.s);\n      cb(null, rpcSig);\n    };\n\n    this.signPersonalMessage = (...args) => {\n      this.signMessage(...args);\n    };\n  }\n\n}\n"]}